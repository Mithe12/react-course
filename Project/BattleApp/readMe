/* First Component */
1. we are going to scaffold the project using babel and webpack. We are not using create-react-app project.
2. Run "npm init -y" to initialize the project. This will create package.json with meta information.
3. Run "npm install react react-dom". This will download the packages and place it in node_modules.
4. Creating ".gitignore" file and add node_modules and dist to it.
5. Create an "app" folder and place three file "index.js", "index.html", "index.css"
6. Imported "React" and "React-dom/client" package and created class component and added the component to rootElement.
    // Class component will have state, lifecycle and will render UI.
7. install : npm install --save-dev @babel/core @babel/preset-env @babel/preset-react webpack webpack-cli webpack-dev-server babel-loader css-loader style-loader html-webpack-plugin
8. create a webpack.config.js files
9. we need to configure babel presets in package.json to know what kind of transformation we want to make on our code.
        "@babel/preset-env" ==  Transformation of Modern JS to Browser JS
        "@babel/preset-react" == Transformation of JSX to JS
10. Update the scripts property in package.json and add build webpack to it
11. WE need to take index.html, copy it and place it in dist folder with reference of index_bundle.js as <script> tag.
    // we need to use HtmlWebpackplugin and mention where index.html is located.
12. Support hot-reloading, webpack-dev-server

/* Rendering the list */

1. Created a "Popular" class component and export it as default.
2. we only render method in the class.
3. we need to render UI with drop-down, To do that we can use map().

/* Steps: Managing the State */
1. we need to define the constructor() so that we can get "state" props.
2. Inside the constructor(), we need to "define the object for the state".
3. we need to define updateLanguage that "updates object in the state".
4. we need to "bind" updateLanguage in the constructor to "this" object.
5. Finally, we need to do capture onChange event and then trigger updateLanguage method and set the "selected"
6. Display the result of state in the UI as test

Note: when user click the option, it will trigger the updateLanguage method that will update the state property "selectedLanguage". Since state is changed, React will render UI and it will use "selectedLanguage" to show the options and tick mark in the UI.

/* Functional Components */
1. If your component take props and render UI based on props, then we can use functional components.
2. function HelloWorld(props){
        return <div> {props} </div>
    } 
NOTE: In the code, The functional components doesn't contain business logic, we are telling functional components "what to do" (declarative) instead of "How to do" (imperative). We are passing the current state of the language and the function to change the state. Parent component will contain the business logic and then pass the state and function to change the state to child component. State management will be handled by parent component.

/* Proptypes - Type check */
    1. we need to make sure props that passed to components are right type. --> Predictable 
    2. we need to attach "propTypes" property to components that accept props.
    3. "propTypes" property has a object that contains props and its data type.
    4. Warning will be showed if not right type in the console. (Failed PropTypes)
    5. we need to import PropTypes from "prop-types"

STEPS:
    1. Install npm install prop-types 
    2. Import the PropTypes from the "prop-types"
    3. Attach propTypes to the LanguagesNav Components. 

/* Component Life Cycle */

GENERAL:
    1. Componens core responsibility 
        - Manage their own state.
        - Recieve data via props.
        - Describe thier UI based on state.
    2. In more complex application, Components need to take more responsibilites such as
        - Ajax Request
        - Setting and removing listeners

LIFE CYCLE OF COMPONENTS: 
    1. MOUNTING: When Components gets added to DOM.

        ~ Usual Things need to occur on Mounting phase
            - Setting up initial state for the component.
                + constructor() 
            - Rendering the DOM element for the component.
                + render() = its pure function, only examine state and props and return a UI description.
            - Make AJAX Request.
                + ComponentDidMount() = invoked only once when component is first mounted to DOM
            - Setting up listeners (websockets / Firebase)
                + ComponentDidMount()

    2. UPDATING: When Components updates its state or recieve new data via props.

        ~ Usual Things need to occur on UPDATING phase
            - Re-render UI with updated state or props.
                - render() = When even the state or props updated, render() will be called again
            - Re-fecting data. (we need to refetch the data without re-mounting the component)
                - ComponentDidUpdate(prevProps, prevState):
                    - Method will be invoked after the component state or props changes.
                    - With 2 args, it allows to compare prevState/props with currentState/props and do something on it
            - Re-setting data.
                - ComponentDidUpdate(prevProps,prevState)

    3. UnMounting: When Components gets removed from DOM.
        - Removing Listeners/ Clean up actions = ComponentWillUnmount()


    class App extends React.Component {

        constructor(props){
            // Good for establishing initial state of a component
            super(props)
            this.state = {}
        }

        componentDidMount(){
            // Invoked once the component is mounted to DOM
            // Good for making AJAX request
        }
        
        componentDidUpdate(){
            // Invoked immediately after updating occurs
            // Good for AJAX request based on changing props
            // or DOM Operations
        }

        componentWillUnmount(){
            // Called right before a component is unmounted.
            // Good for cleaning up listeners
        }

        render(){
            // pure function - based on state describe UI
        }
    }

STEPS: 
    1. Create api.js in util folder, call the github endpoint for the languages.
        - the fetch will get the response, then get the data from the response objec, if data contains item return it.
    2. Import the fetchPopular Repo in the Popular.jsx
    3. we need to call fetchPopularRepos when the component is mount also we need to call it whenever user changes the language, so we need to place the fetching logic in updateLanguage (we can use whenever user changes the langugae) and we use updateLanguage in componentDidMount (when first time its mounted)
    4. Also, we need to update the state object to include, repo infomration and error information
    5. Inside updateLanguage, we need to call fetchRepos that return promise, and if the promise is success, set the repos and error to null or else catch the error and set only error value in the state.
    6. Finally, based on the state, update the UI

    1. Create a Table Component, that is functional component and don't have state and define the PropTypes for it.
    2. We need to create TableHead Component and TabeRow Component. In the table body, for every repos, we need to create tableRow Component.
    3. TableHead Component, we define the Head names for it in the componet.
    4. TableRow Component, we destructe only neccessary data from repo and build UI for that and include propTypes.
    5. Finally import Table Component in Popular.js and pass the repos to it .


/* Controlled vs UnControlled */

1. Forms without React: The Form state lives inside DOM, and whenever you need it, grab it from DOM. --> Uncontrolled
2. Forms With React: Form state lives inside React Components --> Controlled Components

/* Battle App */

1. Create a Root Component called as Battle and define the state (PlayerOne and PlayerTwo)
2. we have 3 Parts for Battle Component:
    - Define the Battle Button 
    - Define Section with playerInput form (Update the Root Component state)
    - Define the Instrunctions Components
3. We need to define the playerInput Form as the Class becos its going to have state and we will be passing props from Root Component to this.
    - Since its a form, we are having a state called "username" and onSubmit and onChange.
    - OnChange will pass the event. Using the event get the value and update the state.
    - OnSubmit will pass the event, Using that prevent default and call the root onSubmit to change the root state.
4. Root Component, we need to define the function that changes the state and create higherorder function which smartly updates the state.

5. When we press "Battle" button, we need to show the result component with user information.
    - we need to create battle boolean in state object, initially we need to set to false, when we press battle button, we will update the battle state to true. React api will re-render the UI object, it will render the Result component.

6. Update the api.js to include the calc repos and create Result component that shows thw winner.

7.
